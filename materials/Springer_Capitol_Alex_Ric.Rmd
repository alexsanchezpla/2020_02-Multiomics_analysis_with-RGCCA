---
title: "Statistical Analysis of Microarray Data"
author: "Ricardo Gonzalo Sanz and Alex Sanchez Pla"
date: "March 26, 2019"
output:
  bookdown::word_document2:
    fig_caption: yes
  html_document: default
  word_document: default
editor_options:
  chunk_output_type: console
csl: springer-basic-brackets.csl
bibliography: references.bib
---

```{r setup, include=FALSE}
require(knitr)
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, 
                      comment = NA, prompt = TRUE, tidy = FALSE, 
                      fig.width = 7, fig.height = 7, fig_caption = TRUE,
                      cache=FALSE)
Sys.setlocale("LC_TIME", "C")
```

```{r echo=FALSE}
if(!(require(printr))) {
  install.packages(
    'printr',
    type = 'source',
    repos = c('http://yihui.name/xran', 'http://cran.rstudio.com')
  )
}
```

## Running Head

__Statistical analysis of microarray data__

## Summary/Abstract

Microarray data analysis has been one of the most important hits in the interaction between statistics and bioinformatics in the last two decades. The analysis of microarray data can be done in different ways using different tools. In this chapter a typical workflow for analyzing microarray data using R and Bioconductor packages is presented. The workflow starts with the raw data -binary files obtained from the hybridization process- and goes through a series of steps: Reading raw data, Quality Check, Normalization, Filtering, Selection of differentially expressed genes, Comparison of selected lists and Analysis of Biological Significance. The implementation of each step in R is described through a use case that goes from raw data until the analysis of biological significance. Data and code for the analysis are provided in a Github repository.
 
## Key Words
microarrays, Bioconductor, R, Differential expression

## Introduction

Microarray data analysis is one of the most clear cases where interaction between bioinformatics and statistics has been  highly beneficial for both disciplines. Efron @Efron2013 even calls the 21st century as the century of microarrays. 

What is generically described as "microarray data analysis" is a process that starts with the design of the experiment intended to answer with one or more biological questions and ends with a temptative answer for these questions. Statistics is involved at every step of this process, for preparing, transforming visualizing or analyzing data. And, of course, every step can be done in different way that use either classical statistics or new methods developed ad-hoc for these often high dimensional problems. The detailed description of these steps is out of the scope of this chapter and the reader is assumed to be familiar with  It is assumed that the reader is already familiar with microarrays such as they are introduced in @Sanchez-Pla2014 and also with the general ideas of microarray data analysis such as can be found in @Draghici2012. In any case, for the sake of completeness basic ideas will be briefly introduced and citations provided the first time they are discussed.

For our objectives we can assume that a microarray dataset is a matrix of continuous values that represent the expressions of a set of genes (one gene per row), in a variety of conditions or samples (one sample per column). See figure 1 for an example.

```{r dataset, fig.cap="A simplified view of a gene expression matrix", echo=FALSE}
knitr::include_graphics("figures/gene_exp_matrix.jpg")
```

Our main goal is to describe a workflow, a series of ordered steps, that takes us from the raw data, the digitized images as produced by the hybridization system to one or more lists of genes that can be used to help answering a certain biological question.
This can be done in distinct ways. What we present here is an approach that has become very popular along the last decades based on analyzing the data from the images to the lists of genes, using the R Statistical language and some of the packages developed specifically for this in the Bioconductor project.

A summary of the process can be found in figure 2.

```{r MDAProcess, fig.cap="The microarray data analysis process", echo=FALSE}
knitr::include_graphics("figures/c04analysisProcess.png")
```

## Materials
In this section we list all the materials needed to perform a microarray data analysis. First of all it is needed to install the software necessary to perform all the required calculations. Different options are available but the more extended one is to used the __R statistical software__. R can be downloaded from its web page (https://cran.r-project.org/index.html) and installed following the instructions described there. The microarray analysis presented in this chapter has been performed with the latest version of R, which was in that moment 3.4.4. This is a command line program and an user friendly interface to work with it is to use R-Studio, that can be downloaded and installed following the instructions listed in its web page: https://www.rstudio.com/. R-studio version used for this analysis was 1.1.383.

__Data__ for the example of microarray analysis has been obtained from the public database Gene Expression Omnibus (GEO). GEO is a public repository of microarray data, where all the data of published experiments are accessible there. The experiment we have chosen is identified with the accession number: __GSE100924__ @LiE7111. The experiment tries to determine how Zbtb7b, which is a zinc finger and BTB domain containing transcription factor that activates the thermogenic gene program during brown and beige adipocyte differentiation, regulates brown fat gene expression at ambient room temperature and following cold exposure. Wild type and Zbtb7b knockout mice of 10 weeks of age were kept at ambient room temperature (22C) or following cold exposure at 4C for 4 hrs. Therefore the design of the experiment was two factors (genotype and temperature) with two levels each (wild type and knock out, for genotype, and room temperature and cold, for temperature). The sample size of the experiment is 12 samples, three replicates of each group. The microarray used for this experiment was Mouse Gene 2.1 from Affymetrix (Thermofisher), vendor of microarray technology.

When working with R often it is required to use some functions not allocated in the basic installation of R software, and it is necessary to install them from specific packages developed by the scientific community. Most of packages used for the analysis of high throughput genomic data are deposited on the Bioconductor repository (https://www.bioconductor.org/). Here we will provide a list and a little description of all the packages it is necessary to install to run the microarray analysis. In the following section we will show the code necessary to install all of them:

+ __Oligo__: Oligo is  a Bioconductor package  for  preprocessing  oligonucleotide  microarrays. We use this package to read the CEL files and normalize them. @oligo
+ __pd.mogene.2.1.st__: It is an annotation package for the array used in this experiment. @pdmogene
+ __Biobase__: This package contains standardized data structures to represent genomic data that are used by other R packages. @biobase
+ __Array Quality Metrics__: This package generates microarray quality metrics reports for microarray data. @AQM
+ __ggplot2__: This package is a plotting system for R. We will use it to build nice graphs @ggplot2
+ __ggrepel__: This is also a graphic package for R, and with it we will avoid overlapping of labels in plots @ggrepel
+ __pvca__: This package contains the functions necessary to assess the batch effect sources involved in a microarray experiment @pvca
+ __limma__: Limma is an R package for the analysis of gene expression microarray data, especially the use of linear models for analyzing designed experiments and the assessment of differential expression. @Smyth2005
+ __genefilter__: The genefilter package can be used to filter (select) genes from a microarray dataset according to a variety of different filtering mechanisms. @genefilter
+ __xtable__: A R package to print tables in html format. @xtable
+ __annotate__: An R package for managing annotations that is, providing functions to extract information from annotation packages, which are essentially databases containing information about genes and related features. @anotate
+ __org.Mm.eg.db__: Annotation package for mouse. Contains multiple SQL tables relating gene information from mouse with different databases. The main key for all tables is the Entrez Gene identifier, a unique integer number for every gene in every organism. There are multiple organism-centric annotation packages named as: "org.XX.eg.db". Each package  provides information on organism "XX"", indexed by the Entrez Gene  identifiers, "eg", of this organism. @orgMm
+ __mogene21sttranscriptcluster.db__: Platform-centric annotation package. Instead of providing information using the Entrez Gene identifiers these databases use the specific c identifiers of (at the probeset or transcript level) of a given type of array as indexes to link to other databases. @mogene21 
+ __gplots__: Various R programming tools for plotting data. @gplots

## Methods

1. __Folders creation and definition:__

In a microarray data analysis project, data analyst will have to manage a lot of files, including the files with the raw data (.CEL files) and the files generated during the analysis of them. For this reason, it is very advisable to define some folders before beginning with the analysis to try to not get lost, if all the files go to the same folder. We strongly recommend that user creates the following folders:
  + A main folder for example in the computer desktop called for example "MicroarraysAnalysis"
  + Inside the main folder, another one called __data__: Here we will save all the _.CEL_ files and the _targets_ file (in following sections we will explain what is an how to create it).
  + Inside the main folder, another one called __results__: Here we will send all the results obtained in the microarray analysis.

With the following orders we are going to create the desired folders. This also can be made as usual with the files explorer of your operative system of your computer (in that case you can omit this steps):

```{r CreateFolders, warning=FALSE, eval=FALSE}
dir.create("MicroarraysAnalysis")
dir.create("MicroarraysAnalysis/data")
dir.create("MicroarraysAnalysis/results")
```

After creating the folders we save into the _"MicroarraysAnalysis"_ folder the file with the microarray analysis script, that can be downloaded from [https://github.com/alexsanchezpla/StatisticalAnalysisOfMicroarrayData](https://github.com/alexsanchezpla/StatisticalAnalysisOfMicroarrayData). Once it is saved, you can open R-Studio, open the file with the R code, and in R-Studio go to the menu option in the top "Session -> Set working directory -> To source file location". This action will set _MicroarraysAnalysis_ folder as our working folder.

2. __Prepare the data to analyze__

As commented before the .CEL files from your experiment, that are the files with the raw data originated after microarray scanning and preprocessing with Affymetrix software, have to be saved into the recently created __data__ folder. It is expected to find a .CEL file for each sample in the experiment.

Another file we need before beginning is the _targets_ file, which can be easily created with an spreadsheet. This file will relate the name of each .CEL file with their condition in the experiment. We can use the targets to retain all the information valuable for the analysis like other covariables. A example of targets file is shown in next figure:

```{r targetsAspect, fig.cap="This is how the targets file for this study looks like", echo=FALSE}
knitr::include_graphics("figures/Screenshot_targets.png")
```

Although the targets file need not have any fixed names it is practical to use its columns names to create labels that will be used later. For example:

  - Column called _FileName_: It may contain the exact name of the CEL files in the data folder
  - Column called _Group_: It may summarize the conditions in the experiment for that sample.
  - Column called _ShortName_: It may be used to store a short label of the sample useful for some plots.
  - There may be other columns to store covariables in the study such as sex, age, etc.
  
For this analysis, targets file has been saved in csv format, separated by semicolon. It is important for the following step, to read the targets file.

3. __Read the targets file__

The information on covariates stored in the "We have to store the information of "targets" can be saved in a text or .csv file and read into R for managing the information about samples.

```{r ReadTargets}
targets <- read.csv2("./data/targets.csv", header = TRUE, sep = ";") 
```

4. __Packages installation in R__

As commented in _Materials_ section, packages will be mainly downloaded from Bioconductor repository, but there will be others downloaded from CRAN repository. Those allocated in Bioconductor are download with the function _biocLite("name of the package")_ and those from CRAN with the function _install.packages("name of the package")_. With the following code, we are going to download them:

```{r installPackages, message=FALSE, warning=FALSE, results='hide'}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
if (!require(oligo)) BiocManager::install("oligo", version = "3.8") else detach(package:oligo)
if (!require(pd.mogene.2.1.st)) BiocManager::install("pd.mogene.2.1.st", version = "3.8") else detach(package:pd.mogene.2.1.st)
if (!require(arrayQualityMetrics)) BiocManager::install("arrayQualityMetrics", version = "3.8") else detach(package:arrayQualityMetrics)
if (!require(colorspace)) BiocManager::install("colorspace", version = "3.8") else detach(package:colorspace)
if (!require(ggplot2)) BiocManager::install("ggplot2", version = "3.8") else detach(package:ggplot2)
if (!require(ggrepel)) BiocManager::install("ggrepel", version = "3.8") else detach(package:ggrepel)
if (!require(limma)) BiocManager::install("limma", version = "3.8") else detach(package:limma)
if (!require(genefilter)) BiocManager::install("genefilter", version = "3.8") else detach(package:genefilter)
if (!require(xtable)) BiocManager::install("xtable", version = "3.8") else detach(package:xtable)
if (!require(mogene21sttranscriptcluster.db)) BiocManager::install("mogene21sttranscriptcluster.db", version = "3.8") else detach(package:mogene21sttranscriptcluster.db)
if (!require(annotate)) BiocManager::install("annotate", version = "3.8") else detach(package:annotate)
if (!require(org.Mm.eg.db)) BiocManager::install("org.Mm.eg.db", version = "3.8") else detach(package:org.Mm.eg.db)
if (!require(ReactomePA)) BiocManager::install("ReactomePA", version = "3.8") else detach(package:ReactomePA)
if (!require(gplots)) BiocManager::install("gplots", version = "3.8") else detach(package:gplots)
if (!require(gplots)) BiocManager::install("pvca", version = "3.8")
```

5. __Read the CEL files__

Next step is to read the raw data (CEL files) and to store in a variable (in this case we have called it **rawData**). First we have to load the package _oligo_ with the function _library_. In this package are coded the functions to read the CEL files. Take attention to put the correct folder where the CEL files are saved when executing _list.celfiles_ function. 

```{r ReadCELfiles, message=FALSE, results='hide', warning=FALSE}
require(oligo)
celFiles <- list.celfiles("./data", full.names = TRUE)
require(Biobase)
my.targets <-read.AnnotatedDataFrame(file.path("./data","targets.csv"), 
                                     header = TRUE, row.names = 1, sep=";") 
rawData <- read.celfiles(celFiles, phenoData = my.targets)
```

Look that we have read another time the targets file, but now using another specific function: _read.AnnotatedDataFrame_, and stored in a new variable called _my.targets_. We have done that to associate the information stored in the CEL files with the targets file in on single variable with the last code's line. This object is called _ExpressionSet_ and is designed to combine several different sources of information into a single convenient structure. We could store in this object all the information available about the experiment performed (protocol used, experiment data, microarray type,...). Moreover it allow us to change the long name of the samples, for the short and more comprehensive label previously coded in _ShortName_ column of the _targets_.

```{r ChangeName}
colnames(rawData) <-rownames(pData(rawData)) <- my.targets@data$ShortName
```

6. __Quality control of raw data__

Once the raw data is loaded it is the moment to check if the data have enough quality for normalization. This step is very important since bad quality data could introduce a lot of noise in the analysis, that normalization process could not solve. ArrayQualityMetrics package performs different quality approaches, like boxplot of the intensity of the data and Principal Component Analysis (PCA) among others. If one array is above a certain threshold defined in the function it is marked with an asterisk as an outlier. When a certain array is marked three times it should be revised carefully, perhaps this sample will have to be rejected to improve the overall quality of the experiment.
First step is to load the library to gain access to the function. Be careful again to specify correctly the destination folder of the results:

```{r QCRaw, message=FALSE, warning=FALSE, eval=FALSE}
require(arrayQualityMetrics)
arrayQualityMetrics(rawData, outdir = file.path("./results", "QCDir.Raw"), force=TRUE)
```

We have to check the results of the quality analysis in a recently created QCDir.Raw folder inside the results folder previously created. Inside this folder we have to look for a file called _index.html_, which open a web page from where we will be able to access to all the analysis performed. For our analysis, three samples has been marked once to be an outlier, therefore we can continue working with all of them.

```{r QCRawDataRes, fig.cap="This is how the Screenshot of arrayQualityMetrics results (index.html file) looks like", echo=FALSE}
knitr::include_graphics("figures/Screenshot_QCRaw.png")
```

A more comprehensive principal component analysis could be obtained using a specific function design for that. We can download the function before using it from the specific Github repository . 

```{r PCARaw, message=FALSE, fig.align='center', fig.height=6, fig.width=6, fig.cap="Visualization of the two first PCs"}
source("https://raw.githubusercontent.com/uebvhir/UEB_PCA/master/UEB_plotPCA3.R")
plotPCA3(exprs(rawData), labels = targets$ShortName, factor = targets$Group, 
         title="Raw data", scale = FALSE, size = 3, 
         colores = c("red", "blue", "green", "yellow"))
```

If necessary, it is easy to save the plots to a _tiff_ file with the following code:

```{r savePCAraw, echo=FALSE, results='hide'}
tiff("figures/PCA_RawData.tiff", res = 200, width = 4, height = 4, units = 'in')
plotPCA3(exprs(rawData), labels = targets$ShortName, factor = targets$Group, 
         title="Raw data", scale = FALSE, size = 2, 
         colores = c("red", "blue", "green", "yellow"))
dev.off()
```


Note that we have defined in the function some parameters:

  + the label of the samples, remember that it is coded in the _ShortName_ column of the targets
  + the characteristic to color the samples, coded in the _Group_ column in targets
  + the colors of each group
  
First component of the PCA accounts for 55.9% of the total variability of the samples, and as we can observe in the plot, this variability is mainly contributed by the _temperature_ condition since samples incubated to 4 degrees are on the right and samples incubated at room temperature are on the left.

In the same way, we can easily plot the intensity distribution of the arrays with a specific function to perform a boxplot:

```{r BoxplotRaw, message=FALSE, fig.align='center', fig.height=6, fig.width=6, fig.cap="Boxplot for arrays intensities (Raw Data)"}
boxplot(rawData, cex.axis=0.5, las=2,  which="all", 
         col = c(rep("red", 3), rep("blue", 3), rep("green", 3), rep("yellow", 3)),
         main="Distribution of raw intensity values")
```

```{r saveIntensRaw, echo=FALSE, results='hide'}
tiff("figures/Intensity_RawData.tiff", res = 200, width = 4, height = 4, units = 'in')
boxplot(rawData, cex.axis=0.5, las=2,  which="all", 
         col = c(rep("red", 3), rep("blue", 3), rep("green", 3), rep("yellow", 3)),
         main="Distribution of raw intensity values")
dev.off()
```


A light variation of intensity among arrays is observed, but this is the expected for raw data.

7. __Data normalization__

Before beginning with differential expression analysis, it is necessary to make the arrays comparable among them and try to reduce, and if it is possible to eliminate, all the variability in the samples not owing to biological reasons.Normalization process tries to assure that intensity differences present in the array, reflects the differential expression of the genes, rather than artificial biases due to technical issues. Normalization process consists of three discrete steps: background correction, normalization, and summarization. Most commonly used method for array normalization is Robust Multichip Analysis @rmaIri:

```{r Normalization}
eset_rma <- rma(rawData)
```

8. __Quality control of normalized data__

After performing normalization it is interesting to perform again a quality control to check how data looks. In the same way than before (look we have changed _rawData_ object to *eset_rma*):

```{r QCNorm, message=FALSE, warning=FALSE, eval=FALSE}
arrayQualityMetrics(eset_rma, outdir = file.path("./results", "QCDir.Norm"), force=TRUE)
```

```{r QCNormDataRes, fig.cap="This is how the Screenshot of arrayQualityMetrics results (index.html file) looks like for the normalized data", echo=FALSE}
knitr::include_graphics("figures/Screenshot_QCNorm.png")
```

```{r PCANorm, message=FALSE,fig.align='center', fig.height=6, fig.width=6, fig.cap="Visualization of first two principal components for normalized data"}
plotPCA3(exprs(eset_rma), labels = targets$ShortName, factor = targets$Group, 
         title="Normalized data", scale = FALSE, size = 3, 
         colores = c("red", "blue", "green", "yellow"))
```

```{r savePCAnorm, echo=FALSE, results='hide'}
tiff("figures/PCA_NormData.tiff", res = 150, width = 5, height = 5, units = 'in')
plotPCA3(exprs(eset_rma), labels = targets$ShortName, factor = targets$Group, 
         title="Normalized data", scale = FALSE, size = 2, 
         colores = c("red", "blue", "green", "yellow"))
dev.off()
```


Now first component accounts for 33% of the total variability, and like in the PCA with raw data, it separates samples from _COLD_ level of _temperature_ condition on the right, and samples from _RT_ level on the left. It is important to note that there are one sample from group _KO.RT_ that groups near __WT.RT__ and viceversa. It could be an issue of mislabeling of samples that should be checked with the laboratory that has processed the samples.


```{r BoxplotNorm, message=FALSE, fig.align='center', fig.height=6, fig.width=6, fig.cap="Distribution of raw intensities for normalized data"}
boxplot(eset_rma, cex.axis=0.5, las=2,  which="all", 
         col = c(rep("red", 3), rep("blue", 3), rep("green", 3), rep("yellow", 3)),
         main="Boxplot for arrays intensity: Normalized Data")
```


```{r saveIntensNorm, echo=FALSE, results='hide'}
tiff("figures/Intensity_NormData.tiff", res = 150, width = 5, height = 5, units = 'in')
boxplot(eset_rma, cex.axis=0.5, las=2,  which="all", 
         col = c(rep("red", 3), rep("blue", 3), rep("green", 3), rep("yellow", 3)),
         main="Boxplot for arrays intensity: Normalized Data")
dev.off()
```

Look that after normalization, intensity of arrays is very similar.

9. __Batch detection__

Gene expression microarray results can be affected by minuscule differences in any number of non-biological variables like reagents from different lots, different technicians and the more usual issue the different processing date of samples from the same experiment. The cumulative error introduced by these time and place-dependent experimental variations is referred to as "batch effects". Different approaches have been developed for identifying and removing batch effects from microarray data like surrogate variable analysis, Combat and Principal variation component analysis (PVCA). 
Here we will use the last one, Principal variation component analysis, which estimates source and proportion of variation in two steps, principal component analysis, and variance component analysis. Only for illustration purposes we have added a new column to our targets file, with a fictitious sample processing date. We will perform the PVCA analysis before and after adding this columns to see the differences:
```{r BatchDetection, message=FALSE, warning=FALSE, fig.align='center'}
#load the library
require(pvca)
pData(eset_rma) <- targets
#select the threshold
pct_threshold <- 0.6
#select the factors to analyze
batch.factors <- c("Genotype", "Temperature")
#run the analysis
pvcaObj <- pvcaBatchAssess (eset_rma, batch.factors, pct_threshold)
```

```{r plotPVCA, fig.cap="Relative importance of the different factors affecting gene expression"}
#plot the results
bp <- barplot(pvcaObj$dat, xlab = "Effects",
  ylab = "Weighted average proportion variance",
  ylim= c(0,1.1),col = c("mediumorchid"), las=2,
  main="PVCA estimation")
axis(1, at = bp, labels = pvcaObj$label, cex.axis = 0.55, las=2)
values = pvcaObj$dat
new_values = round(values , 3)
text(bp,pvcaObj$dat,labels = new_values, pos=3, cex = 0.5)
```

```{r savePVCAplot, echo=FALSE, results='hide'}
tiff("figures/PVCAplot.tiff", res = 150, width = 5, height = 5, units = 'in')
bp <- barplot(pvcaObj$dat, xlab = "Effects",
  ylab = "Weighted average proportion variance",
  ylim= c(0,1.1),col = c("mediumorchid"), las=2,
  main="PVCA estimation")
axis(1, at = bp, labels = pvcaObj$label, cex.axis = 0.45, las=2)
values = pvcaObj$dat
new_values = round(values , 3)
text(bp,pvcaObj$dat,labels = new_values, pos=3, cex = 0.5)
dev.off()
```

As we can see in the last plot the main source of variation in the samples is the _Temperature_ condition. This was also the same we observed when we perform the PCA with the samples (see last point of the protocol).

10. __Detecting most variable probesets__

Selection of differential expressed genes is affected by the number of genes on which we make it. The higher the number, the greater the necessary adjustment of p-values (as will be seen below), which will lead us to end up miscarrying more genes.

If a gene is differential expressed, it is necessary that there is a certain difference between the groups, and therefore the overall variance of the gene will be greater than that of those that do not have differential expression. 
Plotting the overall variability of all genes is useful to decide which percentage of genes shows a variability that can be attributed to other causes than random variation.

```{r SDplot, fig.cap="Distribution of standard deviations allong all samples for all genes"}
sds <- apply (exprs(eset_rma), 1, sd)
sdsO<- sort(sds)
plot(1:length(sdsO), sdsO, main="Distribution of variability for all genes",
     sub="Vertical lines represent 90% and 95% percentiles",
     xlab="Gene index (from least to most variable)", ylab="Standard deviation")
abline(v=length(sds)*c(0.9,0.95))
```

```{r saveSDplot, echo=FALSE, results='hide'}
tiff("figures/SDplot.tiff", res = 150, width = 5, height = 5, units = 'in')
plot(1:length(sdsO), sdsO, main="Distribution of variability for all genes",
     sub="Vertical lines represent 90% and 95% percentiles",
     xlab="Gene index (from least to most variable)", ylab="Standard deviation")
abline(v=length(sds)*c(0.9,0.95))
dev.off()
```

The plot suggests that the most variable probesets are those with a standard deviation above 90-95% of all standard deviations.

11. __Filtering least variable probesets__

Filtering out those genes whose variability can be attributed to random variation, that is the genes that are, reasonably, not expected to be differential expressed, has proven to be useful to reduce the number of tests to be performed with the corresponding increase in power @Hackstadt2009.

Function `nsFilter` from the bioconductor package `genefilter` can be used to remove genes based on a variability threshold. If an annotation package -associating probesets identifiers and gene identifiers from different databases- is available it can also be used to remove probesets which do not have a gene identifier associated.

```{r Filtering1, results='hide', message=FALSE}
require(genefilter)
annotation(eset_rma) <- "mogene21sttranscriptcluster.db"
filtered <- nsFilter(eset_rma, 
                     require.entrez = TRUE, remove.dupEntrez = TRUE,
                     var.filter=TRUE, var.func=IQR, var.cutoff=0.75, 
                     filterByQuantile=TRUE, feature.exclude = "^AFFX")
```

Function `nsFilter` returns the filtered values and a report of the filtering results.
```{r FilterResults1, results='hide', echo=FALSE}
names(filtered)
class(filtered$eset)
```

```{r FilterResults2}
print(filtered$filter.log)
eset_filtered <-filtered$eset
```

After filtering there are `r dim(exprs(eset_filtered))[1]` probesets left. Look that we have stored the probesets left in the variable *eset_filtered*

12. __Saving normalized and filtered data__

Normalized filtered data are the starting point for further analyses but we may want to go back to them, for example to review specific gene expression values. It is usual to save the binary objects but also to write expression values into text or excel files. Writing to Excel from R is not a trivial task -for strange it may seem- because different packages work differently depending of the operating system, so it is omitted from the code.

```{r SaveData1, results='hide', message=FALSE}
write.csv(exprs(eset_rma), file="./results/normalized.Data.csv")
write.csv(exprs(eset_filtered), file="./results/normalized.Filtered.Data.csv")
save(eset_rma, eset_filtered, file="./results/normalized.Data.Rda")
```

13. __Defining the experimental setup: The design matrix__

Selection of differential expressed genes basically consists of doing some type of test,  usually on a gene-wise basis, to compare gene expression between groups. This can be done using many different approaches (see @Chrominski2015). There is a general agreement that using standard statistical tests such as t-tests is not appropriate @Jeanmougin2010 and that better options are methods that perform some type of variance shrinking @Allison2006. Techniques specifically developed for microarrays such as SAM @Tusher2001 or Linear Models for Microarrays @Smyth2004 have proved to produce much better results @Chrominski2015.

In this protocol the Linear Models for Microarrays method, implemented in the limma package @Smyth2005 is used to select differential expressed genes.

The first step for the analysis based on linear models is to create the __design matrix__. Basically it is a table that describes the allocation of each sample to a group or experimental condition. It has as many rows as samples and as many columns as groups (if only one factor is considered).
Each row contains a one in the column of the group to which the sample belongs and a zero in the others.

The design matrix can be defined manually or from a factor variable that may have been introduced in the "targets" file with this aim created specifically for it. In this study  that "Group" variable is a combination of the two experimental conditions, "KO/Wild" and "RT/COLD" which are jointly represented as one factor with 4 levels.

```{r LoadSavedData}
if (!exists("eset_filtered")) load (file="./results/normalized.Data.Rda")
```


```{r DesignMatrix, message=FALSE}
require(limma)
designMat <- model.matrix(~0 + Group, pData(eset_filtered))
colnames(designMat) <- c("KO.COLD", "KO.RT", "WT.COLD", "WT.RT")
print(designMat)
```


14. __Defining comparisons with the Contrasts Matrix__ 

The contrasts matrix is used to describe the comparisons between groups 
It consists of as many columns as comparisons and as many rows as
groups (that is, as columns of the design matrix). 
A comparison between groups - called "contrast" - is represented by a "1" and a "-1" in the rows of groups to compare and zeros in the rest. 
If several groups intervened in the comparison would have as many coefficients as groups with the only restriction that its sum would be zero.

In this example we want to check the effect of knocking out a gene ("KO vs WT") separately for cold and RT temperature. Also we want to test if there is interaction between knocking out the gene and temperature. This can be done by doing three comparisons described below:

```{r. setContrasts}
cont.matrix <- makeContrasts (KOvsWT.COLD = KO.COLD - WT.COLD,
                              KOvsWT.RT = KO.RT - WT.RT,
                              INT = (KO.COLD - WT.COLD) - (KO.RT - WT.RT),
                              levels = designMat)
print(cont.matrix)
```

The contrast matrix is defined to perform three comparisons: Effect of KO in Cold temperature, Effect of KO in RT temperature and interaction between KO and temperature.

15 __Model estimation and gene selection__

Once the design matrix and the contrasts have been defined, we can proceed to estimate the model, estimate the contrasts and perform the significance tests that will lead to the decision, for each gene and each comparison, if they can be considered differential expressed.

The method implemented in the \texttt{limma} package extends the traditional analysis using
Empirical Bayes models to combine an estimate of variability based on the entire matrix with individual estimates based on each individual values providing improved error estimates @Smyth2004.

The analysis provides the usual test statistics such as Fold-change
t-moderated or adjusted p-values that are used to order the genes from more
unless differential expressed.

In order to control the percentage of false positives that may result from
high number of contrasts made simultaneously the p-values are adjusted
so that we have control over the false positive rate using the
Benjamini and Hochberg method @Benjamini1995.

All relevant information for further exploration of the results is stored in an R object of class `MArrayLM` defined in the `limma` package. Here it is named as `fit.main`.

```{r, linearmodelfit}
require(limma)
fit <- lmFit(eset_filtered, designMat)
fit.main <- contrasts.fit(fit, cont.matrix)
fit.main <- eBayes(fit.main)
class(fit.main)
```

16 __Obtaining lists of differentially expressed genes__

The \texttt{limma} package implements function `topTable` which contains, for a given contrast a list of genes ordered from smallest to biggest p--value which can be considered to be most to least differential expressed. For each gene the following statistics are provided:
\begin{itemize}
\item  \texttt{logFC:} Mean difference between groups.  
\item   \texttt{AveExpr:} Average expression of all genes in the comparison.
\item   \texttt{t :} Moderated t-statistic (t-test-like statistic for the comparison).
\item   \texttt{P.Value:} Test p--value.  
\item   \texttt{adj.P.Val:} Adjusted p--value following @Benjamini1995      
\item   \texttt{B:} B-statistic: Posterior log odds of the gene of being vs non being differential expressed.
\end{itemize}

We can have a look at the first lines of each topTable.

For comparison 1 (KOvsWT.COLD): Genes that change their expression between KO and WT in cold temperature:

```{r, topTabs1}
topTab_KOvsWT.COLD <- topTable (fit.main, number=nrow(fit.main), coef="KOvsWT.COLD", adjust="fdr") 
head(topTab_KOvsWT.COLD)
```

For comparison 2 (KOvsWT.RT): Genes that change their expression between KO and WT in room temperature:

```{r, topTabs2}
topTab_KOvsWT.RT <- topTable (fit.main, number=nrow(fit.main), coef="KOvsWT.RT", adjust="fdr") 
head(topTab_KOvsWT.RT)
```

For comparison 3 (INT): Genes that behave differently between comparison 1 and 2:

```{r, topTabs3}
topTab_INT  <- topTable (fit.main, number=nrow(fit.main), coef="INT", adjust="fdr") 
head(topTab_INT)
```


First column of each topTable contains the manufacturer's (Affymetrix) ID for each probeset. Next step is to guess which gene correspond to each Affymetrix ID. This process is called **annotation**.

17. __Gene Annotation__

Once we have the top table it is useful to provide additional information on the features that have been selected. This process is called "annotation" and essentially what it does is to look for information to associate "criptic" identifiers that appear in the top table, usually probesets or transcripts, with more familiar names such as the Gene Symbol, the Entrez Gene identifier or the Gene description.

For simplicity, because there are three toptables, a function annotating one topTable with a given package is prepared and used.

```{r GeneAnnotation, message=FALSE, warning=FALSE}
annotatedTopTable <- function(topTab, anotPackage)
{
  topTab <- cbind(PROBEID=rownames(topTab), topTab)
  myProbes <- rownames(topTab)
  thePackage <- eval(parse(text = anotPackage))
  geneAnots <- select(thePackage, myProbes, c("SYMBOL", "ENTREZID", "GENENAME"))
  annotatedTopTab<- merge(x=geneAnots, y=topTab, by.x="PROBEID", by.y="PROBEID")
return(annotatedTopTab)
}
```

```{r annotateTopTables}
annotated_KOvsWT <- annotatedTopTable(topTab_KOvsWT.COLD,
anotPackage = "mogene21sttranscriptcluster.db")
head(annotated_KOvsWT)
annotated_KOvsWT.COLD <- annotatedTopTable(topTab_KOvsWT.COLD,
anotPackage = "mogene21sttranscriptcluster.db")
annotated_KOvsWT.RT <- annotatedTopTable(topTab_KOvsWT.RT,
anotPackage = "mogene21sttranscriptcluster.db")
annotated_INT <- annotatedTopTable(topTab_INT,
anotPackage = "mogene21sttranscriptcluster.db")
write.csv(annotated_KOvsWT.COLD, file = "./results/annotated_KOvsWT_COLD.csv")
write.csv(annotated_KOvsWT.RT, file = "./results/annotated_KOvsWT_RT.csv")
write.csv(annotated_INT, file="./results/annotated_INT.csv")
```

18. __Visualizing differential expression__

A visualization of the overall differential expression can be obtained using volcano-plots. These plots show if there are many or few genes with a large fold-change and significantly expressed or if this number is low. These graphs represent in the X-axis the changes of expression in logarithmic scale ("biological effect") and in the Y-axis the "minus logarithm" of the p-value or alternatively the `B` statistic ("Statistical effect").

```{r volcanoPlot, fig.cap="Volcano plots for the first comparisons performed"}
require(mogene21sttranscriptcluster.db)
geneSymbols <- select(mogene21sttranscriptcluster.db, rownames(fit.main), c("SYMBOL"))
SYMBOLS <- geneSymbols$SYMBOL
volcanoplot(fit.main, coef=1, highlight=10, names=SYMBOLS, 
            main=paste("Differentially expressed genes", colnames(cont.matrix)[1], sep="\n"))
  abline(v=c(-1,1))

```

```{r saveVolcanos, results='hide'}
tiff("figures/VolcanoPlot.tiff", res = 150, width = 5, height = 5, units = 'in')
volcanoplot(fit.main, coef=1, highlight=10, names=SYMBOLS, 
            main=paste("Differentially expressed genes", colnames(cont.matrix)[1], sep="\n"))
  abline(v=c(-1,1))

dev.off()

pdf("figures/Volcanos.pdf")
for (i in colnames(cont.matrix)){
  volcanoplot(fit.main, coef=i, highlight=10, names=SYMBOLS,
              main=paste("Differentially expressed genes",i, sep="\n"))
  abline(v=c(-1,1))
}
dev.off()
```

19. __Multiple Comparisons__

When one selects genes in several comparisons it is usually interesting to know which genes have been selected in each comparison. Sometimes biologically relevant genes will be those that are selected in one of them but not in others. In other occasions he interest will lie in genes that are selected in all comparisons.

Functions `decideTests` and `VennDiagram` from package limma can be used to annotate and count the genes selected in every comparison.

```{r decideTests.1}
require(limma)
res <- decideTests(fit.main, method = "separate", adjust.method = "fdr", p.value = 0.1, lfc = 1)
```

This object has as many columns as comparisons and as many rows as genes. Per each gene  and comparison a +1 denotes significantly up-regulated (t-test values $>0$a -1 significantly down-regulated and a 0 non significant difference).

```{r resumeDecideTests}
sum.res.rows <- apply(abs(res), 1, sum)
res.selected <- res[sum.res.rows != 0, ] 
print(summary(res))
```

This can be visualized in a Venn Diagram.

```{r, venndiagram, fig.cap="Venn diagram showing the genes in common between the three comparisons performed"}
vennDiagram (res.selected[,1:3], cex = 0.9)
title("Genes in common between the three comparisons\n Genes selected with FDR < 0.1 and logFC > 1")
```

```{r vennPlot, results='hide'}
tiff("figures/VennPlot.tiff", res = 150, width = 5.5, height = 5.5, units = 'in')
vennDiagram (res.selected[,1:3], cex = 0.9)
title("Genes in common between the three comparisons\n Genes selected with FDR < 0.1 and logFC > 1")
dev.off()
```

20. __Heatmaps__

Genes that have been selected as differential expressed may be visualized using a heatmap. These plots use color palettes to highlight distinct values --here positive (up-regulation) or negative (down-regulation) significantly differential expressions. 

_Heatmaps_ can be used to visualize the expression values of differential expressed genes with no specific order, but it is usually preferred to plot them doing a hierarchical clustering on genes (rows) or columns(samples) in order to find groups of genes with common patterns of variation which can eventually be associated to the different groups being compared.

There may be discussion on which genes to select for doing a heatmap. A common option is to select the gens that have been selected in the previous steps, that is the genes that have been called differential expressed in at least one comparison.

```{r data4Heatmap}
probesInHeatmap <- rownames(res.selected)
HMdata <- exprs(eset_filtered)[rownames(exprs(eset_filtered)) %in% probesInHeatmap,]

geneSymbols <- select(mogene21sttranscriptcluster.db, rownames(HMdata), c("SYMBOL"))
SYMBOLS<- geneSymbols$SYMBOL
rownames(HMdata) <- SYMBOLS

dim(HMdata);head(HMdata)
write.csv(HMdata, file = file.path("./results/data4Heatmap.csv"))
```

With the selected data a heatmap can be generated with or without clustering genes and/or samples.

```{r heatmapNoclustering, fig.cap="Heatmap for expression data without any grouping"}
my_palette <- colorRampPalette(c("blue", "red"))(n = 299)
require(gplots)

heatmap.2(HMdata,
          Rowv = TRUE,
          Colv = TRUE,
          main = "Differentially expressed genes \n FDR < 0,1, logFC >=1",
          scale = "row",
          col = my_palette,
          sepcolor = "white",
          sepwidth = c(0.05,0.05),
          cexRow = 0.5,
          cexCol = 0.9,
          key = TRUE,
          keysize = 1.5,
          density.info = "histogram",
          ColSideColors = c(rep("red",3),rep("blue",3), rep("green",3), rep("yellow",3)),
          tracecol = NULL,
          dendrogram = "both",
          srtCol = 30)
```

```{r heatmapClustering, fig.cap="Heatmap for expression data grouping genes (rows) by their similarity"}
heatmap.2(HMdata,
          Rowv = FALSE,
          Colv = FALSE,
          dendrogram = "none",
          main = "Differentially expressed genes \n FDR < 0,1, logFC >=1",
          scale = "row",
          col = my_palette,
          sepcolor = "white",
          sepwidth = c(0.05,0.05),
          cexRow = 0.5,
          cexCol = 0.9,
          key = TRUE,
          keysize = 1.5,
          density.info = "histogram",
          ColSideColors = c(rep("red",3),rep("blue",3), rep("green",3), rep("yellow",3)),
          tracecol = NULL,
          srtCol = 30)

```

```{r results='hide'}
tiff("figures/Heatmap1.tiff", res = 150, width = 5.5, height = 5.5, units = 'in')
heatmap.2(HMdata,
          Rowv = TRUE,
          Colv = TRUE,
          main = "Differentially expressed genes \n FDR < 0,1, logFC >=1",
          scale = "row",
          col = my_palette,
          sepcolor = "white",
          sepwidth = c(0.05,0.05),
          cexRow = 0.5,
          cexCol = 0.9,
          key = TRUE,
          keysize = 1.5,
          density.info = "histogram",
          ColSideColors = c(rep("red",3),rep("blue",3), rep("green",3), rep("yellow",3)),
          tracecol = NULL,
          dendrogram = "both",
          srtCol = 30)
dev.off()

tiff("figures/Heatmap2.tiff", res = 150, width = 5.5, height = 5.5, units = 'in')
heatmap.2(HMdata,
          Rowv = FALSE,
          Colv = FALSE,
          dendrogram = "none",
          main = "Differentially expressed genes \n FDR < 0,1, logFC >=1",
          scale = "row",
          col = my_palette,
          sepcolor = "white",
          sepwidth = c(0.05,0.05),
          cexRow = 0.5,
          cexCol = 0.9,
          key = TRUE,
          keysize = 1.5,
          density.info = "histogram",
          ColSideColors = c(rep("red",3),rep("blue",3), rep("green",3), rep("yellow",3)),
          tracecol = NULL,
          srtCol = 30)
dev.off()
```

21. __Biological Significance of results__

Once a list of gene has being obtained that characterizes the difference between two conditions it has to be interpreted. Although this requires, of course, a good understanding of the underlying biological problem, a statistical approach known as "Gene Set Analysis" can be useful for suggesting ideas for the interpretation.

With this aim these types of analyses seek to establish whether, given a list of genes selected for being differential expressed between two conditions, the functions, biological processes or molecular pathways that characterize them appear on this list more frequently than among the rest of the genes analyzed.

There are many variants of these types of analysis, see @Khatri2012,  but here we will use the basic enrichment analysis as described in  implemented in the `ReactomePA` Bioconductor package. The analysis is done on the ReactomePA annotation database [https://reactome.org/](https://reactome.org/).

Analyses of this type need a minimum number of genes to be reliable, preferably a few hundreds than a few dozens, so it is common to perform a selection less restrictive than with the previous steps. 
For instance an option is to include all genes with a non-stringent FDR cutoff, such as FDR < 0.15 without filtering by minimum "fold-change").

As a first step we prepare the list of gene lists that will be analyzed:

```{r selectGenes}
listOfTables <- list(KOvsWT.COLD = topTab_KOvsWT.COLD, 
                     KOvsWT.RT  = topTab_KOvsWT.RT, 
                     INT = topTab_INT)
listOfSelected <- list()
for (i in 1:length(listOfTables)){
  # select the toptable
  topTab <- listOfTables[[i]]
  # select the genes to be included in the analysis
  whichGenes <- topTab["adj.P.Val"] < 0.15
  selectedIDs <- rownames(topTab)[whichGenes]
  # convert the ID to Entrez
  EntrezIDs <- select(mogene21sttranscriptcluster.db, selectedIDs, c("ENTREZID"))
  EntrezIDs <- EntrezIDs$ENTREZID
  listOfSelected[[i]] <- EntrezIDs
  names(listOfSelected)[i] <- names(listOfTables)[i]
}
sapply(listOfSelected, length)
```

The analysis also requires to have the Entrez Identifiers for all genes.

```{r}
mapped_genes <- mappedkeys(org.Mm.egGO)
```

The Biological significance analysis will be applied only to the first two lists. Sometimes yet another decomposition is applied so that up and downregulated genes are separately analyzed. This will not be done here because there is no clear biological argument to proceed so in all cases.

```{r BiologicalSig}
require(ReactomePA)

listOfData <- listOfSelected[1:2]
comparisonsNames <- names(listOfData)
universe <- mapped_genes

for (i in 1:length(listOfData)){
  genesIn <- listOfData[[i]]
  comparison <- comparisonsNames[i]
  enrich.result <- enrichPathway(gene = genesIn,
                                 pvalueCutoff = 0.05,
                                 readable = T,
                                 pAdjustMethod = "BH",
                                 organism = "mouse",
                                 universe = universe)
  
  cat("##################################")
  cat("\nComparison: ", comparison,"\n")
  print(head(enrich.result))

  if (length(rownames(enrich.result@result)) != 0) {
  write.csv(as.data.frame(enrich.result), 
             file =paste0("./results/","ReactomePA.Results.",comparison,".csv"), 
             row.names = FALSE)
  
  pdf(file=paste0("./results/","ReactomePABarplot.",comparison,".pdf"))
    print(barplot(enrich.result, showCategory = 15, font.size = 4, 
            title = paste0("Reactome Pathway Analysis for ", comparison,". Barplot")))
  dev.off()
  
  pdf(file = paste0("./results/","ReactomePAcnetplot.",comparison,".pdf"))
    print(cnetplot(enrich.result, categorySize = "geneNum", schowCategory = 15, 
         vertex.label.cex = 0.75))
  dev.off()
  }
}
```

The results obtained in the analysis of biological significance are:

  - a _.csv_ file with a summary of all the enriched pathways and the associated statistics
  - a bar plot with the best enriched pathways. Height of the bar plot is the number of genes of our analysis related with that pathway. Moreover, pathways are  ordered by statistical significance.
  - a plot with a network of the enriched pathways and the relation among the genes included.

In our study for comparison _KOvsWT.COLD_  three different enriched pathways have been found, one of them is _Synthesis of very long-chain fatty acyl-CoAs_, and in comparison _KOvsWT.RT_, five enriched pathways have been found. The more statistically relevant is _ Inositol phosphate metabolism_.

22. __Summary of results__

Once the process has been completed one has obtained a, sometimes long, list of files with the data and the analysis results. These files are of the basis for discussing the results and looking for a biological interpretation. Both aspects exceed the goals of this chapter so they are omitted here.

It is useful to create a file with the type, name and description of all the files generated along the analysis. Table 1 shows the list of files generated in the current case study.

```{r}
FileName <- list.files("./results/", pattern = NULL, all.files = FALSE, recursive = FALSE, 
                       full.names = FALSE, include.dirs = TRUE,no.. = FALSE)

write.csv(FileName, file.path("./results/", "listOfFiles.txt"), row.names = FALSE)
FileName
```


# References


